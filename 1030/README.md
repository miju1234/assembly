; ============================================================
; Chapter 5 — 5.8.1 Short Answer (1~20) : 요약 & 간단 풀이 (MASM)
; Book: Irvine, "Assembly Language for x86 Processors", 7e
; ============================================================

;------------------------------------------------------------
; Q1. 런타임 스택이 하는 일?
; A. LIFO 저장소. CALL 시 반환주소 push, 임시값/지역변수/보존레지스터 저장.
;    PUSH: ESP -= item_size 후 저장, POP: 읽고 ESP += item_size.
;------------------------------------------------------------

;------------------------------------------------------------
; Q2. CALL 과 RET 의 차이?
; A. CALL: (다음 명령 주소=RA) 를 스택에 push 후 대상으로 분기.
;    RET : 스택 top(반환주소)을 pop→EIP 로 복귀.

;------------------------------------------------------------
; Q3. 인자 전달(레지스터 vs 스택) 선택 기준?
; A. 소수의 간단 인자→레지스터(EAX/EBX/ECX 등). 개수 많거나 가변→스택.

;------------------------------------------------------------
; Q4. 반환값 레지스터는?
; A. 관례적으로 EAX. 그러므로 EAX 를 push/pop 으로 “복원”하면 결과를 덮어써 손실될 수 있음.

;------------------------------------------------------------
; Q5. 보존해야 할 레지스터는?
; A. 호출 규약/코스 스타일에 따라 피호출자가 사용한 레지스터(특히 ESI/EDI/EBX/ECX 등)를
;    시작에 push, 끝에 pop 으로 복구. (반환값 레지스터 EAX는 예외)

;------------------------------------------------------------
; Q6. PROC USES 의 효과?
; A. 지정한 레지스터들을 자동으로 PUSH/POP(보존/복구)하도록 prologue/epilogue 생성.

;------------------------------------------------------------
; Q7. 중첩 호출에서 루프 카운터(ECX) 등 유지법?
; A. 내부 호출 전 push ecx ... 내부 처리 ... pop ecx  로 원복.

;------------------------------------------------------------
; Q8. 서브루틴에 JMP 대신 CALL 을 쓰는 이유?
; A. JMP 는 RA 저장이 없어 복귀 불가. CALL 은 RA 저장→RET 으로 정상 복귀 가능.

;------------------------------------------------------------
; Q9. 스택을 임시로 쓸 때 주의?
; A. 쓴 만큼 정확히 되돌리기(밸런스). 임의 POP 으로 RA 를 망가뜨리면 RET 실패.

;------------------------------------------------------------
; Q10. 지역변수(로컬) 간단 확보/해제?
; A. sub esp, N  ... 사용 ...  add esp, N   (N=필요 바이트 수).

;------------------------------------------------------------
; Q11. 예: DWORD 로컬 2개(1000h, 2000h) 초기화
; A.
;   sub esp, 8
;   mov dword ptr [esp],   1000h
;   mov dword ptr [esp+4], 2000h
;   ... 사용 ...
;   add esp, 8

;------------------------------------------------------------
; Q12. 인덱스/간접 주소지정 활용?
; A. 배열 순회/복사/합계. TYPE(요소 크기), LENGTHOF(개수) 사용하면 안전·가독성↑.

;------------------------------------------------------------
; Q13. 반환주소를 “출력만” 하려면?
; A. 스택을 변경하지 말고 읽기만:
;   push eax
;   mov  eax, [esp+4]     ; push로 인해 RA가 esp+4 위치
;   ; EAX 출력 (예: WriteHex)
;   pop  eax

;------------------------------------------------------------
; Q14. 반환주소(스택 top) 조작의 위험?
; A. 교육용 데모 외엔 금물. 명령 경계/바이트 수 오계산 시 즉시 크래시.

;------------------------------------------------------------
; Q15. Irvine32 라이브러리 호출 시 일반 규칙?
; A. 각 프로시저 시그니처 준수(예: WriteString ← EDX=문자열 주소,
;    WriteInt/WriteHex ← EAX=값). 호출 전 레지스터 세팅.

;------------------------------------------------------------
; Q16. 플래그 저장/복원?
; A. pushfd / popfd 로 EFLAGS 전체 저장/복원.

;------------------------------------------------------------
; Q17. pushad / popad (32-bit)의 의미?
; A. PUSHAD: EAX,ECX,EDX,EBX,ESP(실행 전),EBP,ESI,EDI 순으로 스택에 저장.
;    POPAD : 역순으로 복원.

;------------------------------------------------------------
; Q18. ArraySum 류의 패턴에서 보존할 것?
; A. 포인터/카운터(ESI/ECX 등) push/pop 으로 보존. 반환값은 EAX.

;------------------------------------------------------------
; Q19. (원문 선택형) 다음 코드 실행 후 라인 6에서 EDX 값은?
;   main:
;     mov edx,0
;     mov eax,40
;     push eax
;     call Ex5Sub
;     ; <-- 여기서 EDX ?
;   Ex5Sub:
;     pop  eax
;     pop  edx
;     push eax
;     ret
; 풀이) CALL 시 스택: [top]=RA, 그 아래=40.
;      pop eax -> EAX=RA,  pop edx -> EDX=40,  push eax -> top=RA, ret 정상복귀.
; 정답) EDX = 40.

;------------------------------------------------------------
; Q20. (원문) 다음 코드 실행 후 array 내용?
;   초기: EAX=10, ESI=0
;   proc_3: array[ESI] = EAX         ; array[0] = 10
;   proc_2: add ESI,4 / add EAX,10   ; array[4] = 20
;   proc_1: add ESI,4 / add EAX,10   ; array[8] = 30
;   main  : add ESI,4 / add EAX,10   ; array[12] = 40
; 정답) array = [10, 20, 30, 40]
;------------------------------------------------------------
